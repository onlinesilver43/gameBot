#!/usr/bin/env python3
"""
Post-commit hook for automated documentation maintenance.
Runs after commits to trigger background maintenance tasks.
"""

import os
import sys
import subprocess
import json
from pathlib import Path
from typing import List, Dict, Any


def get_last_commit_info() -> Dict[str, Any]:
    """Get information about the last commit."""
    try:
        # Get commit hash
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )
        commit_hash = result.stdout.strip()

        # Get commit message
        result = subprocess.run(
            ["git", "log", "--format=%B", "-n", "1", "HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )
        commit_msg = result.stdout.strip()

        # Get changed files
        result = subprocess.run(
            ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", "HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )
        changed_files = result.stdout.strip().split('\n')

        return {
            "hash": commit_hash,
            "message": commit_msg,
            "files": changed_files,
            "significant": is_significant_commit(changed_files, commit_msg)
        }

    except subprocess.CalledProcessError as e:
        print(f"Warning: Could not get commit info: {e}")
        return {}


def is_significant_commit(files: List[str], message: str) -> bool:
    """Determine if commit requires special handling."""
    # Significant if it changes core functionality
    significant_patterns = [
        '.py', '.md', '.yml', '.json',
        'bsbot/', 'docs/', 'config/',
        'requirements.txt', 'setup.py'
    ]

    has_significant_files = any(
        any(pattern in file for pattern in significant_patterns)
        for file in files
    )

    # Or if commit message indicates major change
    significant_keywords = ['feat', 'breaking', 'major', 'refactor']
    has_significant_message = any(
        keyword in message.lower()
        for keyword in significant_keywords
    )

    return has_significant_files or has_significant_message


def trigger_ci_checks():
    """Trigger automated CI checks if available."""
    try:
        # Check if we're in a CI environment
        if os.environ.get('CI'):
            print("🔄 CI environment detected, skipping local triggers")
            return

        # Check if GitHub CLI is available
        result = subprocess.run(
            ["gh", "--version"],
            capture_output=True,
            check=True
        )

        # Trigger workflow if possible
        workflow_path = repo_root / ".github" / "workflows" / "docs-check.yml"
        if workflow_path.exists():
            print("🚀 Triggering documentation checks...")

            # This would trigger the workflow - in practice you'd need proper authentication
            # subprocess.run(["gh", "workflow", "run", "docs-check.yml"], cwd=repo_root)

    except (subprocess.CalledProcessError, FileNotFoundError):
        # GitHub CLI not available or not authenticated
        pass


def update_documentation_metadata():
    """Update documentation metadata files."""
    try:
        metadata_file = repo_root / "docs" / ".metadata.json"

        # Get repository statistics
        result = subprocess.run(
            ["git", "ls-files"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )
        files = result.stdout.strip().split('\n')

        # Count files by type
        file_counts = {}
        for file_path in files:
            if file_path and '.' in file_path:
                ext = file_path.split('.')[-1]
                file_counts[ext] = file_counts.get(ext, 0) + 1

        # Get last commit info
        result = subprocess.run(
            ["git", "log", "--format=%H|%s|%ai", "-n", "1"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )

        commit_info = result.stdout.strip().split('|')
        last_commit = {
            "hash": commit_info[0],
            "message": commit_info[1],
            "date": commit_info[2]
        }

        # Update metadata
        metadata = {
            "last_updated": last_commit["date"],
            "last_commit": last_commit["hash"],
            "file_counts": file_counts,
            "total_files": len([f for f in files if f.strip()]),
            "documentation_files": len([f for f in files if f.startswith('docs/')])
        }

        with open(metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2)

    except Exception as e:
        print(f"Warning: Could not update metadata: {e}")


def log_commit_summary(commit_info: Dict[str, Any]):
    """Log a summary of the commit for documentation purposes."""
    try:
        log_file = repo_root / "docs" / "commit-log.md"

        # Read existing log or create new
        if log_file.exists():
            with open(log_file, 'r', encoding='utf-8') as f:
                content = f.read()
        else:
            content = "# Commit Log\n\nAutomatically generated commit summaries.\n\n"

        # Add new entry
        new_entry = f"## {commit_info['hash'][:8]}\n\n"
        new_entry += f"**Date:** {commit_info.get('date', 'Unknown')}\n"
        new_entry += f"**Message:** {commit_info['message']}\n"
        new_entry += f"**Files Changed:** {len(commit_info['files'])}\n"

        if commit_info['significant']:
            new_entry += "**Significant:** Yes\n"

        if commit_info['files']:
            new_entry += "\n**Changed Files:**\n"
            for file in commit_info['files'][:10]:  # Limit to first 10
                if file.strip():
                    new_entry += f"- `{file}`\n"
            if len(commit_info['files']) > 10:
                new_entry += f"- ... and {len(commit_info['files']) - 10} more\n"

        new_entry += "\n---\n\n"

        # Insert at top (after header)
        lines = content.split('\n')
        if len(lines) > 2:
            content = '\n'.join(lines[:2]) + '\n\n' + new_entry + '\n'.join(lines[2:])
        else:
            content += new_entry

        # Keep only last 50 commits
        entries = content.split('---')
        if len(entries) > 52:  # Header + 50 entries + current
            content = '---'.join(entries[:52]) + '---'

        with open(log_file, 'w', encoding='utf-8') as f:
            f.write(content)

    except Exception as e:
        print(f"Warning: Could not log commit summary: {e}")


def cleanup_old_artifacts():
    """Clean up old temporary artifacts."""
    try:
        # Clean old log files (keep last 30 days)
        import time

        log_dir = repo_root / "logs"
        if log_dir.exists():
            cutoff = time.time() - (30 * 24 * 60 * 60)  # 30 days ago

            for log_file in log_dir.glob("*.log"):
                if log_file.stat().st_mtime < cutoff:
                    log_file.unlink()
                    print(f"🧹 Cleaned old log: {log_file.name}")

        # Clean old temporary files
        temp_patterns = ["*.tmp", "*.bak", "*~"]
        for pattern in temp_patterns:
            for temp_file in repo_root.rglob(pattern):
                if temp_file.is_file():
                    temp_file.unlink()

    except Exception as e:
        print(f"Warning: Could not cleanup artifacts: {e}")


def main():
    """Main post-commit hook logic."""
    global repo_root
    repo_root = Path(__file__).parent.parent

    print("🔄 Post-commit documentation maintenance...")

    # Get commit information
    commit_info = get_last_commit_info()

    if not commit_info:
        print("⚠️ Could not get commit information")
        return 0

    print(f"📝 Processing commit {commit_info['hash'][:8]}")

    # Trigger CI checks if significant
    if commit_info.get('significant'):
        trigger_ci_checks()

    # Update documentation metadata
    update_documentation_metadata()

    # Log commit summary
    log_commit_summary(commit_info)

    # Cleanup old artifacts
    cleanup_old_artifacts()

    print("✅ Post-commit maintenance complete")
    return 0


if __name__ == "__main__":
    sys.exit(main())
